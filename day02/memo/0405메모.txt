의존하는 것들은 생성자 메서드를 통해 외부에서 주입받는 형태로,
주입하는것은 외부에서 관리하기 편하게 모아놓은 형태로.

통제가 불가능한 부분은 막아야 한다.
(private...)
확장이 용이한 부분은 개방한다.

다형성, 캡슐화
객체지향...

포트폴리오 4월 중순...

컨트롤 왼쪽키 -> 설명 보기...

----------------------------------------------------------------------------

ioc
제어의 역전
개발자가 객체를 만들고, 제어했지만,
스프링이 제어의 역할을 맡게 된다. (다양한 방식으로 관리)

AOP

proxy = 대리하다

핵심적인 로직만 구현하면, 스프링이 거의 다 해준다.

애노테이션을 통해 스프링에게 알려준다.
핵심 - 객체 관리

스프링을 명확하게 이해해야 부트도 잘 쓸 수 있다.

스프링은 객체를 컨테이너에 넣어놓고 관리한다.
의존하는게 있는지 없는지 체크한다.
@Autowired를 달면, 의존 형태로 되어있는 메서드를 인식해서
컨테이너에서 객체를 꺼내서 주입해준다.

스프링은 관리 객체만 관리한다.
@Bean을 꼭 달아주어야 한다.

외부 라이브러리도 @Bean을 달면 쓸 수 있는지 확인해봐야 할듯

@Bean에서 주입 -> @Autowired에서 주입받음...

@Autowired(required = false) = 의존성이 없어도 오류가 발생하지 않게 된다.
----------------------------------------------------------------------------
mvn 리포지토리

Spring Context
5.3.26버전 사용

Project Lombok
1.18.26
------------------------------------------------------------------------------------
스프링 라이프사이클

1. 객체 생성 - 설정 클래스 (스프링 컨테이너 안에다가 객체를 만든다.)
2. 의존성 주입 (객체가 있어야만 주입이 된다.)(@Autowired, 생성자 매개변수)
3. 초기화
	- 의존성 주입 이후에 초기 작업이 있다면
	- InitializingBean 인터페이스
		- afterPropertySet -> 호출
		
4. 소멸
	 - close() 메서드가 호출
		- 자원해제 과정, 웹 서버는 항상 켜져 있기 때문에 따로 자원해제를 해주어야 한다.
	 - 객체를 소멸하기전
	 - DisposableBean 인터페이스
		- destroy 메서드 호출
